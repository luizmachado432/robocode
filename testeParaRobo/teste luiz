package kkk;

import robocode.HitRobotEvent;
import robocode.AdvancedRobot;
import robocode.ScannedRobotEvent;
import robocode.util.Utils;
import java.awt.Color;

public class Teste extends AdvancedRobot {

    // Variáveis para rastreamento
    private String trackName = null; // Nome do robô rastreado
    private double closestDistance = Double.MAX_VALUE; // Distância do robô mais próximo

    // Método principal do robô, chamado quando a batalha começa
    public void run() {
        // Define as cores do robô
        setColors(Color.pink, Color.pink, Color.pink, Color.pink, Color.pink);
        setGunColor(Color.pink);
        setRadarColor(Color.pink);
        setScanColor(Color.pink);
        setBulletColor(Color.pink);

        // Define moveAmount como o maior valor entre a largura e a altura do campo de batalha
        double moveAmount = Math.max(getBattleFieldWidth(), getBattleFieldHeight());

        // Ajusta o robô para ficar alinhado com a parede
        turnLeft(getHeading() % 90);
        // Move o robô até a parede
        ahead(moveAmount);

        // Gira o canhão 90 graus para a direita
        turnGunRight(90);
        // Gira o robô 90 graus para a direita
        turnRight(90);

        // Girar o radar continuamente enquanto procura um robô
        turnRadarRight(360);

        // Loop infinito para manter o robô se movendo
        while (true) {
            // Move o robô para a frente pela distância moveAmount
            ahead(moveAmount);
            turnGunRight(360);
            // Gira o robô 90 graus para a direita
            turnRight(90);
        }
    }

    // Método chamado quando o robô colide com outro robô
    public void onHitRobot(HitRobotEvent e) {
        // Ajusta a rotação do canhão para apontar para o robô inimigo
        double gunTurnAmt = Utils.normalRelativeAngleDegrees(e.getBearing() + (getHeading() - getGunHeading()));
        turnGunRight(gunTurnAmt);

        // Dispara com toda a força
        fire(3);

        // Verifica se o robô inimigo está na frente
        if (e.getBearing() > -90 && e.getBearing() < 90) {
            // Se o robô inimigo estiver na frente, recua 100 unidades
            back(100);
        } else {
            // Se o robô inimigo estiver atrás, avança 100 unidades
            ahead(100);
        }
    }

    // Método chamado quando o robô escaneia outro robô
    public void onScannedRobot(ScannedRobotEvent e) {
        // Calcula a localização exata do robô
        double absoluteBearing = getHeading() + e.getBearing();
        double bearingFromGun = Utils.normalRelativeAngleDegrees(absoluteBearing - getGunHeading());

        // Se estiver perto o suficiente, atira!
        if (Math.abs(bearingFromGun) <= 3) {
            turnGunRight(bearingFromGun);
            // Verificamos o calor da arma aqui, porque chamar fire()
            // consome um turno, o que poderia nos fazer perder rastreio
            // do outro robô.
            if (getGunHeat() == 0) {
                fire(calculateFirePower(e.getDistance()));
            }
        } else {
            // Caso contrário, apenas ajusta a direção da arma.
            turnGunRight(bearingFromGun);
        }
    }

    // Função para calcular a força de tiro com base na distância
    public double calculateFirePower(double distance) {
        if (distance < 100) {
            return 3.0; // Distância curta, força máxima
        } else if (distance < 200) {
            return 2.0; // Distância média, força média
        } else if (distance < 400) {
            return 1.0; // Distância longa, força baixa
        } else {
            return 0.0; // Distância muito longa, força mínima
        }
    }
}
